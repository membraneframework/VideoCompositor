"use strict";(self.webpackChunkcompositor_live=self.webpackChunkcompositor_live||[]).push([[4850,2317],{82110:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var t=i(74848),o=i(28453);const s={},c=void 0,l={id:"common/absolute-position",title:"absolute-position",description:"A component is absolutely positioned if it defines fields like top, left, right, bottom, or rotation.",source:"@site/pages/common/absolute-position.md",sourceDirName:"common",slug:"/common/absolute-position",permalink:"/docs/common/absolute-position",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{}},r={},d=[];function a(e){const n={p:"p",...(0,o.R)(),...e.components};return(0,t.jsx)(n.p,{children:"A component is absolutely positioned if it defines fields like top, left, right, bottom, or rotation.\nThose fields define the component's position relative to its parent. However, to respect those values,\nthe parent component has to be a layout component that supports absolute positioning."})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},31720:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>d,toc:()=>h});var t=i(74848),o=i(28453),s=i(82110);const c=i.p+"assets/images/tile_transition-c296eda8f3214d465d82cf4238311641.webp",l={sidebar_position:4},r="Tiles",d={id:"typescript/components/Tiles",title:"Tiles",description:"Tiles is a layout component that places all the child components next to each other while maximizing the use of available space. The component divides its area into multiple rectangles/tiles, one for each child component. All of those rectangles are the same size and do not overlap over each other.",source:"@site/pages/typescript/components/Tiles.md",sourceDirName:"typescript/components",slug:"/typescript/components/Tiles",permalink:"/docs/typescript/components/Tiles",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"sidebar",previous:{title:"Rescaler",permalink:"/docs/typescript/components/Rescaler"},next:{title:"Text",permalink:"/docs/typescript/components/Text"}},a={},h=[{value:"Absolute positioning",id:"absolute-positioning",level:3},{value:"Static positioning",id:"static-positioning",level:3},{value:"Transitions",id:"transitions",level:3},{value:"TilesProps",id:"tilesprops",level:2},{value:"Transition",id:"transition",level:2},{value:"EasingFunction",id:"easingfunction",level:2}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"tiles",children:"Tiles"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Tiles"})," is a layout component that places all the child components next to each other while maximizing the use of available space. The component divides its area into multiple rectangles/tiles, one for each child component. All of those rectangles are the same size and do not overlap over each other."]}),"\n",(0,t.jsx)("div",{style:{textAlign:"center"},children:(0,t.jsx)("img",{src:c,style:{width:600}})}),"\n",(0,t.jsx)(n.h3,{id:"absolute-positioning",children:"Absolute positioning"}),"\n",(0,t.jsx)(s.default,{}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Tiles"})," ",(0,t.jsx)(n.strong,{children:"does not"})," support absolute positioning for its child components. All children will still be rendered, but all fields like ",(0,t.jsx)(n.code,{children:"top"}),", ",(0,t.jsx)(n.code,{children:"left"}),", ",(0,t.jsx)(n.code,{children:"right"}),", ",(0,t.jsx)(n.code,{children:"bottom"}),", and ",(0,t.jsx)(n.code,{children:"rotation"})," will be ignored."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Tiles"})," ",(0,t.jsx)(n.strong,{children:"can not"})," be absolutely positioned relative to its parent."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"static-positioning",children:"Static positioning"}),"\n",(0,t.jsx)(n.p,{children:"The component calculates the number of rows and columns that children should be divided into. The result is based on:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The size of the ",(0,t.jsx)(n.code,{children:"Tiles"})," component."]}),"\n",(0,t.jsxs)(n.li,{children:["Aspect ratio of a single tile (",(0,t.jsx)(n.code,{children:"tile_aspect_ratio"})," field)."]}),"\n",(0,t.jsx)(n.li,{children:"Number of children components."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"An optimal number of rows and columns should result in a layout that covers the biggest part of its area. Child components are placed based on their order, from left to right, and row-by-row from top to bottom."}),"\n",(0,t.jsx)(n.p,{children:"When placing a child component inside a tile, the component might change its size."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Non-layout component scales proportionally to fit inside the parent. If the aspect ratios of a child and its parent do not match, then the component will be centered vertically or horizontally."}),"\n",(0,t.jsxs)(n.li,{children:["Layout component takes the ",(0,t.jsx)(n.code,{children:"width"})," and ",(0,t.jsx)(n.code,{children:"height"})," of a tile. It ignores its own ",(0,t.jsx)(n.code,{children:"width"}),"/",(0,t.jsx)(n.code,{children:"height"})," fields if they are defined."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"transitions",children:"Transitions"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Tiles"})," component does not support size transitions in the same way as ",(0,t.jsx)(n.code,{children:"View"})," or ",(0,t.jsx)(n.code,{children:"Rescaler"})," do. If you want to achieve that effect, you can wrap a ",(0,t.jsx)(n.code,{children:"Tiles"})," component inside a ",(0,t.jsx)(n.code,{children:"View"})," and define a transition on ",(0,t.jsx)(n.code,{children:"View"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Currently, supported transitions:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Adding a new component. When a component is added, all of the existing components move to their new location within ",(0,t.jsx)(n.code,{children:"transition.duration_ms"})," time. At the end of a transition, the new child component shows up without an animation."]}),"\n",(0,t.jsxs)(n.li,{children:["Removing an existing component. When a component is removed, a tile with that item disappears immediately without any animation, and the remaining elements move to their new location within ",(0,t.jsx)(n.code,{children:"transition.duration_ms"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Changing the order of child components."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Adding/removing/changing the order of components can only be properly defined if there is a way to identify child components. We need to know if a specific child in a scene update should be treated as the same item as a child from a previous scene. Currently, identity of a child component is resolved in the following way:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If a child component has an ",(0,t.jsx)(n.code,{children:'"id"'})," defined, then this is its primary way of identification."]}),"\n",(0,t.jsxs)(n.li,{children:["If a child component does not have an ",(0,t.jsx)(n.code,{children:'"id"'})," defined, then it's identified by order inside the ",(0,t.jsx)(n.code,{children:"children"})," list, while only counting components without an ",(0,t.jsx)(n.code,{children:'"id"'}),". For example:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A component without an ",(0,t.jsx)(n.code,{children:'"id"'})," is 1st child in the old scene. After an update, the 1st component has an ",(0,t.jsx)(n.code,{children:'"id"'}),", but the 2nd does not. In this situation, 1st component in the old scene and 2nd in the new one are considered to be the same component. It's the same because 2nd component in a new scene is still 1st if you only count components without an id."]}),"\n",(0,t.jsxs)(n.li,{children:["There are two components without any ",(0,t.jsx)(n.code,{children:'"id"'})," in the old scene. After an update, they switched places (still without any ",(0,t.jsx)(n.code,{children:'"id"'}),"). In that case, there would be no transition. Identification is based on the child components order, so from the ",(0,t.jsx)(n.code,{children:"Tiles"})," component perspective only the content of those children has changed."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"tilesprops",children:"TilesProps"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'type TilesProps = {\n  id?: string;\n  children?: ReactElement[];\n  width?: number;\n  height?: number;\n  backgroundColor?: string;\n  tileAspectRatio?: string;\n  margin?: number;\n  padding?: number;\n  horizontalAlign?: "left" | "right" | "justified" | "center";\n  verticalAlign?: "top" | "center" | "bottom" | "justified";\n  transition?: Transition;\n}\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"id"})," - Id of a component. Defaults to value produced by ",(0,t.jsx)(n.code,{children:"useId"})," hook."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"children"})," - List of component's children."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"width"})," - Width of a component in pixels. Exact behavior might be different based on the parent\ncomponent:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:'If the parent component is a layout, check sections "Absolute positioning" and "Static\npositioning" of that component.'}),"\n",(0,t.jsx)(n.li,{children:"If the parent component is not a layout, then this field is required."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"height"})," - Height of a component in pixels. Exact behavior might be different based on the parent\ncomponent:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:'If the parent component is a layout, check sections "Absolute positioning" and "Static\npositioning" of that component.'}),"\n",(0,t.jsx)(n.li,{children:"If the parent component is not a layout, then this field is required."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"backgroundColor"})," - (",(0,t.jsxs)(n.strong,{children:["default=",(0,t.jsx)(n.code,{children:'"#00000000"'})]}),") Background color in a ",(0,t.jsx)(n.code,{children:"#RRGGBBAA"})," or ",(0,t.jsx)(n.code,{children:"#RRGGBB"})," format."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"tileAspectRatio"})," - (",(0,t.jsxs)(n.strong,{children:["default=",(0,t.jsx)(n.code,{children:'"16:9"'})]}),") Aspect ratio of a tile in ",(0,t.jsx)(n.code,{children:'"W:H"'})," format, where W and H are integers."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"margin"})," - (",(0,t.jsxs)(n.strong,{children:["default=",(0,t.jsx)(n.code,{children:"0"})]}),") Margin of each tile in pixels."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"padding"})," - (",(0,t.jsxs)(n.strong,{children:["default=",(0,t.jsx)(n.code,{children:"0"})]}),") Padding on each tile in pixels."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"horizontalAlign"})," - (",(0,t.jsxs)(n.strong,{children:["default=",(0,t.jsx)(n.code,{children:'"center"'})]}),") Horizontal alignment of tiles."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"verticalAlign"})," - (",(0,t.jsxs)(n.strong,{children:["default=",(0,t.jsx)(n.code,{children:'"center"'})]}),") Vertical alignment of tiles."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"transition"})," - Defines how this component will behave during a scene update. This will only have an\neffect if the previous scene already contained a ",(0,t.jsx)(n.code,{children:"Tiles"})," component with the same id."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"transition",children:"Transition"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"type Transition = {\n  durationMs: number;\n  easingFunction?: EasingFunction;\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"durationMs"})," - Duration of a transition in milliseconds."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"easingFunction"})," - (",(0,t.jsxs)(n.strong,{children:["default=",(0,t.jsx)(n.code,{children:'"linear"'})]}),") Easing function to be used for the transition."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"easingfunction",children:"EasingFunction"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'type EasingFunction = \n  | "linear"\n  | "bounce"\n  | {\n      functionName: "cubic_bezier";\n      points: [number, number, number, number];\n    }\n'})}),"\n",(0,t.jsx)(n.p,{children:"Easing functions are used to interpolate between two values over time."}),"\n",(0,t.jsxs)(n.p,{children:["Custom easing functions can be implemented with cubic B\xe9zier.\nThe control points are defined with ",(0,t.jsx)(n.code,{children:"points"})," field by providing four numerical values: ",(0,t.jsx)(n.code,{children:"x1"}),", ",(0,t.jsx)(n.code,{children:"y1"}),", ",(0,t.jsx)(n.code,{children:"x2"})," and ",(0,t.jsx)(n.code,{children:"y2"}),". The ",(0,t.jsx)(n.code,{children:"x1"})," and ",(0,t.jsx)(n.code,{children:"x2"})," values have to be in the range ",(0,t.jsx)(n.code,{children:"[0; 1]"}),". The cubic B\xe9zier result is clamped to the range ",(0,t.jsx)(n.code,{children:"[0; 1]"}),".\nYou can find example control point configurations ",(0,t.jsx)(n.a,{href:"https://easings.net/",children:"here"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>c,x:()=>l});var t=i(96540);const o={},s=t.createContext(o);function c(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);